<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>GLTF Scene Viewer</title>
<style>
  body { margin: 0; overflow: hidden; font-family: Arial, sans-serif; }
  canvas { display: block; }
  #menu {
    position: absolute;
    top: 20px;
    left: 20px;
    background: rgba(0, 0, 0, 0.8);
    padding: 20px;
    border-radius: 8px;
    color: white;
    z-index: 1000;
  }
  #menu h2 {
    margin: 0 0 15px 0;
    font-size: 18px;
  }
  #menu button {
    display: block;
    width: 100%;
    padding: 10px;
    margin: 5px 0;
    background: #4CAF50;
    color: white;
    border: none;
    border-radius: 4px;
    cursor: pointer;
    font-size: 14px;
    transition: background 0.3s;
  }
  #menu button:hover {
    background: #45a049;
  }
  #menu button:active {
    background: #3d8b40;
  }
  #info {
    position: absolute;
    bottom: 20px;
    left: 20px;
    background: rgba(0, 0, 0, 0.7);
    padding: 15px;
    border-radius: 8px;
    color: white;
    font-size: 12px;
  }
  #controls {
    position: absolute;
    top: 20px;
    right: 20px;
    background: rgba(0, 0, 0, 0.8);
    padding: 20px;
    border-radius: 8px;
    color: white;
    z-index: 1000;
    min-width: 200px;
  }
  #controls h3 {
    margin: 0 0 10px 0;
    font-size: 16px;
  }
  #controls label {
    display: block;
    margin: 10px 0 5px 0;
    font-size: 12px;
  }
  #controls input[type="range"] {
    width: 100%;
  }
  #controls .value {
    display: inline-block;
    float: right;
    font-weight: bold;
  }
  #controls button {
    width: 100%;
    padding: 8px;
    margin: 10px 0 0 0;
    background: #2196F3;
    color: white;
    border: none;
    border-radius: 4px;
    cursor: pointer;
    font-size: 12px;
  }
  #controls button:hover {
    background: #1976D2;
  }
</style>
</head>
<body>

<div id="menu">
  <h2>Select Scene</h2>
  <button onclick="loadScene('factory')">Factory</button>
  <button onclick="loadScene('neo_tokyo')">Neo Tokyo</button>
  <button onclick="loadScene('snowfall')">Snowfall</button>
  <button onclick="loadScene('refinery')">Refinery</button>
  <button onclick="loadScene('vineyard')">Vineyard</button>
  <button onclick="loadScene('forest')">Forest</button>
</div>

<div id="info">
  <strong>Controls:</strong><br>
  WASD - Move | Space - Up | Shift - Down<br>
  C - Toggle Camera Mode<br>
  Click - Enable Mouse Look (Walking Mode)
</div>

<div id="controls">
  <h3>Settings</h3>
  <label>
    FOV: <span class="value" id="fovValue">75</span>
  </label>
  <input type="range" id="fovSlider" min="30" max="120" value="75" step="1">
  
  <label>
    Speed: <span class="value" id="speedValue">0.20</span>
  </label>
  <input type="range" id="speedSlider" min="0.01" max="0.5" value="0.20" step="0.01">
  
  <button id="wireframeToggle">Toggle Wireframe</button>
</div>

<script type="importmap">
{
  "imports": {
    "three": "https://cdn.jsdelivr.net/npm/three@0.162.0/build/three.module.js"
  }
}
</script>

<script type="module">
import * as THREE from "three";
import { GLTFLoader } from "https://cdn.jsdelivr.net/npm/three@0.162.0/examples/jsm/loaders/GLTFLoader.js";
import { DRACOLoader } from "https://cdn.jsdelivr.net/npm/three@0.162.0/examples/jsm/loaders/DRACOLoader.js";
import { OrbitControls } from "https://cdn.jsdelivr.net/npm/three@0.162.0/examples/jsm/controls/OrbitControls.js";

// Scene
const scene = new THREE.Scene();
scene.background = new THREE.Color(0xaaaaaa);

// Camera
const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.01, 1000);
camera.position.set(0, 0.5, 1);

// Renderer
const renderer = new THREE.WebGLRenderer({ antialias:true });
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

// Lights
const light = new THREE.DirectionalLight(0xffffff, 1);
light.position.set(5, 10, 7.5);
scene.add(light);

const light2 = new THREE.DirectionalLight(0xffffff, 0.5);
light2.position.set(-5, 10, -7.5);
scene.add(light2);

scene.add(new THREE.AmbientLight(0xffffff, 0.3));

const hemiLight = new THREE.HemisphereLight(0xffffff, 0x444444, 0.2);
hemiLight.position.set(0, 20, 0);
scene.add(hemiLight);

// DRACO loader
const dracoLoader = new DRACOLoader();
dracoLoader.setDecoderPath('https://cdn.jsdelivr.net/npm/three@0.162.0/examples/jsm/libs/draco/');

// GLTF loader
const loader = new GLTFLoader();
loader.setDRACOLoader(dracoLoader);

// Current loaded scene
let currentScene = null;
let allMeshes = [];

// Base path for GLTF files - change this to match your server structure
// Examples: './' for same directory, './models/' for models subfolder, '/gltf/' for root gltf folder
const GLTF_BASE_PATH = './';

// Wireframe toggle
let wireframeEnabled = false;
document.getElementById('wireframeToggle').addEventListener('click', () => {
    wireframeEnabled = !wireframeEnabled;
    allMeshes.forEach(mesh => {
        if(Array.isArray(mesh.material)) {
            mesh.material.forEach(mat => mat.wireframe = wireframeEnabled);
        } else {
            mesh.material.wireframe = wireframeEnabled;
        }
    });
});

// Load scene function
window.loadScene = function(sceneName) {
    // Remove existing scene
    if(currentScene) {
        scene.remove(currentScene);
        allMeshes = [];
    }
    
    const filename = `${GLTF_BASE_PATH}${sceneName}.gltf`;
    console.log(`Loading ${filename}...`);
    console.log(`Full path: ${window.location.origin}${window.location.pathname.substring(0, window.location.pathname.lastIndexOf('/'))}/${filename}`);
    
    // Load GLTF
    loader.load(filename, (gltf) => {
        console.log('GLTF loaded');
        
        const gltfJson = gltf.parser.json;
        const nodeExtras = gltfJson.nodes[0].extras;
        
        console.log('Materials in extras:', nodeExtras.materials);
        console.log('Groups in extras:', nodeExtras.groups);
        
        gltf.scene.traverse((node) => {
            if (node.isMesh) {
                console.log('Processing mesh:', node.name);
                allMeshes.push(node);
                
                const nodeExtras = gltfJson.nodes[0].extras;
                
                // Simple approach: analyze geometry normals to determine material
                const geometry = node.geometry;
                const normals = geometry.attributes.normal;
                const indices = geometry.index.array;
                
                // Create grid texture
                const canvas = document.createElement('canvas');
                canvas.width = 512;
                canvas.height = 512;
                const ctx = canvas.getContext('2d');
                
                // Floor texture - orange with white grid
                const floorCanvas = canvas.cloneNode();
                const floorCtx = floorCanvas.getContext('2d');
                floorCtx.fillStyle = '#DC532F';
                floorCtx.fillRect(0, 0, 512, 512);
                floorCtx.strokeStyle = '#ffffff';
                floorCtx.lineWidth = 3;
                const gridSize = 128;
                for(let i = 0; i <= 512; i += gridSize) {
                    floorCtx.beginPath();
                    floorCtx.moveTo(i, 0);
                    floorCtx.lineTo(i, 512);
                    floorCtx.stroke();
                    floorCtx.beginPath();
                    floorCtx.moveTo(0, i);
                    floorCtx.lineTo(512, i);
                    floorCtx.stroke();
                }
                const floorTexture = new THREE.CanvasTexture(floorCanvas);
                floorTexture.wrapS = THREE.RepeatWrapping;
                floorTexture.wrapT = THREE.RepeatWrapping;
                floorTexture.repeat.set(2, 2);
                
                // Wall texture - blue with white grid
                const wallCanvas = canvas.cloneNode();
                const wallCtx = wallCanvas.getContext('2d');
                wallCtx.fillStyle = '#1F5B7E';
                wallCtx.fillRect(0, 0, 512, 512);
                wallCtx.strokeStyle = '#ffffff';
                wallCtx.lineWidth = 3;
                for(let i = 0; i <= 512; i += gridSize) {
                    wallCtx.beginPath();
                    wallCtx.moveTo(i, 0);
                    wallCtx.lineTo(i, 512);
                    wallCtx.stroke();
                    wallCtx.beginPath();
                    wallCtx.moveTo(0, i);
                    wallCtx.lineTo(512, i);
                    wallCtx.stroke();
                }
                const wallTexture = new THREE.CanvasTexture(wallCanvas);
                wallTexture.wrapS = THREE.RepeatWrapping;
                wallTexture.wrapT = THREE.RepeatWrapping;
                wallTexture.repeat.set(2, 2);
                
                const floorMaterial = new THREE.MeshStandardMaterial({
                    map: floorTexture,
                    side: THREE.DoubleSide,
                    metalness: 0.1,
                    roughness: 0.8
                });
                
                const wallMaterial = new THREE.MeshStandardMaterial({
                    map: wallTexture,
                    side: THREE.DoubleSide,
                    metalness: 0.1,
                    roughness: 0.8
                });
                
                // Build groups based on normals
                const groups = [];
                let currentIsFloor = null;
                let groupStart = 0;
                
                for(let i = 0; i < indices.length; i += 3){
                    const idx = indices[i];
                    const ny = normals.array[idx * 3 + 1]; // Y component of normal
                    
                    // Floor/ceiling if normal points mostly up/down
                    const isFloor = Math.abs(ny) > 0.7;
                    
                    if(isFloor !== currentIsFloor){
                        if(currentIsFloor !== null){
                            groups.push({
                                start: groupStart,
                                count: i - groupStart,
                                materialIndex: currentIsFloor ? 0 : 1
                            });
                        }
                        currentIsFloor = isFloor;
                        groupStart = i;
                    }
                }
                
                if(currentIsFloor !== null){
                    groups.push({
                        start: groupStart,
                        count: indices.length - groupStart,
                        materialIndex: currentIsFloor ? 0 : 1
                    });
                }
                
                geometry.clearGroups();
                groups.forEach(g => geometry.addGroup(g.start, g.count, g.materialIndex));
                
                node.material = [floorMaterial, wallMaterial];
                console.log('Applied simple floor/wall materials');
            }
        });

        scene.add(gltf.scene);
        currentScene = gltf.scene;
        console.log('Scene added');
        
        // Reset camera position
        camera.position.set(0, playerHeight, 1);
        yaw = 0;
        pitch = 0;
    }, undefined, (error) => {
        console.error(`Error loading ${filename}:`, error);
        console.error('Error details:', error.message);
        alert(`Failed to load ${sceneName}.gltf\n\nMake sure:\n1. The file exists in the same directory as this HTML\n2. The file is named exactly: ${sceneName}.gltf\n3. Check browser console (F12) for more details`);
    });
};

// Controls
const controls = new OrbitControls(camera, renderer.domElement);
controls.enableDamping = true;
controls.dampingFactor = 0.05;
controls.enablePan = false;

// Camera modes
let cameraMode = 'walking'; // 'freecam' or 'walking'
let walkSpeed = 0.20;
let flySpeed = 0.20;
const playerHeight = 0.5;
let groundHeight = 0; // Track the ground level

// FOV and Speed controls
const fovSlider = document.getElementById('fovSlider');
const fovValue = document.getElementById('fovValue');
const speedSlider = document.getElementById('speedSlider');
const speedValue = document.getElementById('speedValue');

fovSlider.addEventListener('input', (e) => {
    const fov = parseFloat(e.target.value);
    camera.fov = fov;
    camera.updateProjectionMatrix();
    fovValue.textContent = fov;
});

speedSlider.addEventListener('input', (e) => {
    const speed = parseFloat(e.target.value);
    walkSpeed = speed;
    flySpeed = speed;
    speedValue.textContent = speed.toFixed(2);
});

// Mouse look for walking mode
let mouseX = 0;
let mouseY = 0;
let pitch = 0;
let yaw = 0;

// Pointer lock for walking mode
renderer.domElement.addEventListener('click', () => {
    if(cameraMode === 'walking'){
        renderer.domElement.requestPointerLock();
    }
});

document.addEventListener('pointerlockchange', () => {
    if(document.pointerLockElement === renderer.domElement){
        console.log('Pointer locked - mouse look enabled');
    } else {
        console.log('Pointer unlocked');
    }
});

document.addEventListener('mousemove', (e) => {
    if(cameraMode === 'walking' && document.pointerLockElement === renderer.domElement){
        const sensitivity = 0.002;
        yaw -= e.movementX * sensitivity;
        pitch -= e.movementY * sensitivity;
        
        // Clamp pitch to prevent camera flipping
        pitch = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, pitch));
    }
});

// Movement
const move = { forward:false, backward:false, left:false, right:false, up:false, down:false };

// Toggle camera mode with C key
document.addEventListener('keydown', (e) => {
    if(e.code === 'KeyC'){
        cameraMode = cameraMode === 'freecam' ? 'walking' : 'freecam';
        console.log('Camera mode:', cameraMode);
        
        if(cameraMode === 'walking'){
            // Set camera to walking height
            camera.position.y = playerHeight;
            controls.enabled = false;
            // Exit pointer lock when switching to walking if not already locked
            if(document.pointerLockElement !== renderer.domElement){
                console.log('Click to enable mouse look in walking mode');
            }
        } else {
            controls.enabled = true;
            if(document.pointerLockElement === renderer.domElement){
                document.exitPointerLock();
            }
        }
    }
});

// Start in walking mode
controls.enabled = false;
camera.position.y = playerHeight;
console.log('Walking mode active - click to enable mouse look');

document.addEventListener('keydown', e => {
    switch(e.code){
        case 'KeyW': move.forward = true; break;
        case 'KeyS': move.backward = true; break;
        case 'KeyA': move.left = true; break;
        case 'KeyD': move.right = true; break;
        case 'Space': move.up = true; break;
        case 'ShiftLeft': move.down = true; break;
    }
});

document.addEventListener('keyup', e => {
    switch(e.code){
        case 'KeyW': move.forward = false; break;
        case 'KeyS': move.backward = false; break;
        case 'KeyA': move.left = false; break;
        case 'KeyD': move.right = false; break;
        case 'Space': move.up = false; break;
        case 'ShiftLeft': move.down = false; break;
    }
});

// Animate
function animate(){
    requestAnimationFrame(animate);

    // Update camera rotation in walking mode
    if(cameraMode === 'walking'){
        camera.rotation.order = 'YXZ';
        camera.rotation.y = yaw;
        camera.rotation.x = pitch;
    }

    const dir = new THREE.Vector3();
    camera.getWorldDirection(dir);
    
    const speed = cameraMode === 'freecam' ? flySpeed : walkSpeed;

    if(cameraMode === 'walking'){
        // Lock to horizontal plane for walking
        dir.y = 0;
        dir.normalize();
    }

    if(move.forward) camera.position.addScaledVector(dir, speed);
    if(move.backward) camera.position.addScaledVector(dir, -speed);

    const strafe = new THREE.Vector3();
    camera.getWorldDirection(strafe);
    if(cameraMode === 'walking'){
        strafe.y = 0;
    }
    strafe.cross(camera.up);
    strafe.normalize();

    if(move.left) camera.position.addScaledVector(strafe, -speed);
    if(move.right) camera.position.addScaledVector(strafe, speed);

    // Vertical movement in both modes
    if(move.up) camera.position.y += speed;
    if(move.down) camera.position.y -= speed;
    
    // In walking mode, keep track of ground but don't enforce it
    if(cameraMode === 'walking'){
        // Allow going below ground, just track where ground level is
        groundHeight = playerHeight;
    }

    if(cameraMode === 'freecam'){
        controls.update();
    }
    
    renderer.render(scene, camera);
}

animate();

// Resize
window.addEventListener('resize', () => {
    camera.aspect = window.innerWidth/window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
});

// Load factory by default
loadScene('factory');
</script>

</body>
</html>